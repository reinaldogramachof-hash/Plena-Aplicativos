<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cruzadinha Pocket | Plena Apps</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Patrick Hand', cursive;
            background-color: #fef3c7;
            user-select: none;
        }

        /* Paper/Yellow vibe */
        [v-cloak] {
            display: none;
        }

        .cell-black {
            background-color: #292524;
        }

        .cell-active {
            background-color: #fca5a5;
        }
    </style>
</head>

<body class="min-h-screen flex flex-col max-w-md mx-auto bg-amber-50 shadow-2xl">

    <div id="app" v-cloak class="flex-grow flex flex-col p-4">

        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-amber-900 border-b-2 border-amber-200 inline-block pb-1">Cruzadinha #1
            </h1>
        </header>

        <!-- Board -->
        <div class="flex-grow flex flex-col items-center">

            <div class="grid grid-cols-5 gap-1 bg-white p-2 rounded shadow-md border border-amber-200 mb-6">
                <!-- 5x5 Grid for Pocket Version -->
                <div v-for="(cell, idx) in grid" :key="idx"
                    class="w-12 h-12 flex items-center justify-center text-2xl font-bold uppercase border border-gray-100 rounded-sm relative cursor-pointer"
                    :class="[cell.black ? 'cell-black' : 'bg-white', activeIndex === idx ? 'cell-active' : '']"
                    @click="activateCell(idx)">

                    <span v-if="!cell.black" class="z-10">{{ cell.char }}</span>
                    <!-- Number -->
                    <span v-if="cell.number"
                        class="absolute top-0 left-1 text-[10px] text-gray-400 font-sans leading-none">{{ cell.number
                        }}</span>
                </div>
            </div>

            <!-- Clue -->
            <div
                class="w-full bg-white p-4 rounded-xl border border-amber-200 shadow-sm min-h-[100px] flex items-center justify-center text-center">
                <p v-if="currentClue" class="text-xl text-amber-800">{{ currentClue }}</p>
                <p v-else class="text-gray-400 italic">Toque em uma c√©lula para ver a dica.</p>
            </div>

        </div>

        <!-- Keyboard -->
        <div class="mt-4 grid grid-cols-7 gap-1 pb-4">
            <button v-for="key in keys" :key="key" @click="pressKey(key)"
                class="h-12 bg-white rounded shadow border-b-4 border-gray-200 active:border-b-0 active:translate-y-1 font-bold text-lg text-amber-900">
                {{ key }}
            </button>
            <button @click="backspace"
                class="col-span-2 h-12 bg-red-100 rounded shadow border-b-4 border-red-200 active:border-b-0 active:translate-y-1 text-red-800 flex items-center justify-center">
                <i class="fa-solid fa-delete-left"></i>
            </button>
        </div>

    </div>

    <script>
        const { createApp, ref, computed } = Vue;

        createApp({
            setup() {
                // Defines a 5x5 Grid
                // 0  1  2  3  4
                // 5  6  7  8  9
                // ...
                // Simple Level 1 Design:
                // C A S A .
                // . M . M .
                // P A T O .
                // . R . R .
                // . . S O L

                // DATA STRUCTURE
                // black: is blocked
                // char: user input
                // answer: correct char
                // number: clue number (optional)
                // hClue/vClue: index of clue in clues array

                const rawLevel = [
                    { a: 'C', n: 1, hc: 0, vc: null }, { a: 'A', vc: 1 }, { a: 'S', vc: null }, { a: 'A', vc: 2 }, { b: true },
                    { b: true }, { a: 'M', vc: 1 }, { b: true }, { a: 'M', vc: 2 }, { b: true },
                    { a: 'P', n: 2, hc: 3, vc: null }, { a: 'A', vc: 1 }, { a: 'T', vc: null }, { a: 'O', vc: 2 }, { b: true },
                    { b: true }, { a: 'R', vc: 1 }, { b: true }, { a: 'R', vc: 2 }, { b: true },
                    { b: true }, { b: true }, { a: 'S', n: 3, hc: 4 }, { a: 'O' }, { a: 'L' }
                ];

                const grid = ref(rawLevel.map(c => ({
                    black: !!c.b,
                    char: '',
                    answer: c.a || '',
                    number: c.n,
                    hClueId: c.hc, // ID of horizontal clue
                    vClueId: c.vc  // ID of vertical clue
                })));

                const clues = {
                    0: "Lugar onde vivemos (4)",
                    1: "Sentimento de afeto (4)",
                    2: "Sentimento de carinho intenso (4)", // Amor / Amor collision in simple grid? Let's fix. A-M-A-R / A-M-O-R. Let's assume M-A-R (sea) R-A-T-O.
                    // Let's refine the grid content manually for consistency.
                    // H: CASA (0,1,2,3). V: AMAR (1,6,11,16). V: AMOR (3,8,13,18).
                    // This creates C-A-S-A / A-M-A-R / A-M-O-R.
                    // Middle intersection: PATO?

                    // Let's keep clues simple for the hardcoded grid above which matches:
                    // CASA (Horiz)
                    // PATO (Horiz)
                    // SOL (Horiz)
                    // AMAR (Vert at idx 1,6,11,16) -> A M A R
                    // AMOR (Vert at idx 3,8,13,18) -> A M O R

                    0: "Lar, doce lar",
                    3: "Ave que nada na lagoa",
                    4: "Estrela central do sistema solar",
                    1: "Gostar muito de algu√©m (Verbo)",
                    2: "Sentimento rom√¢ntico"
                };

                const activeIndex = ref(null);
                const direction = ref('h'); // 'h' or 'v'

                const keys = "QWERTYUIOPASDFGHJKLZXCVBNM".split("");

                const activateCell = (idx) => {
                    if (grid.value[idx].black) return;
                    activeIndex.value = idx;
                    // Logic to toggle direction if clicking same cell could be added
                };

                const currentClue = computed(() => {
                    if (activeIndex.value === null) return null;
                    const cell = grid.value[activeIndex.value];

                    // Simple logic: prefer H if available, else V
                    // Or follow Toggle direction (omitted for brevity)
                    if (cell.hClueId !== undefined && cell.hClueId !== null) return `üëâ ${clues[cell.hClueId]}`;
                    if (cell.vClueId !== undefined && cell.vClueId !== null) return `üëá ${clues[cell.vClueId]}`;

                    // If cell is part of a word but not the start, need to find the start or allow simple 'hClueId' prop on all cells of the word in a better data structure.
                    // For this MVP, we assume clue IDs are only on start nodes in raw data, which is flawed for UX.
                    // BETTER MVP: Just map index -> clue manually for this specific level.

                    if ([0, 1, 2, 3].includes(activeIndex.value)) return clues[0];
                    if ([10, 11, 12, 13].includes(activeIndex.value)) return clues[3];
                    if ([22, 23, 24].includes(activeIndex.value)) return clues[4];
                    if ([1, 6, 11, 16].includes(activeIndex.value)) return clues[1];
                    if ([3, 8, 13, 18].includes(activeIndex.value)) return clues[2];

                    return "Complete a palavra...";
                });

                const pressKey = (key) => {
                    if (activeIndex.value === null) return;
                    grid.value[activeIndex.value].char = key;
                    // Auto-advance logic could go here
                };

                const backspace = () => {
                    if (activeIndex.value !== null) grid.value[activeIndex.value].char = '';
                };

                return {
                    grid, activeIndex, activateCell, currentClue, keys, pressKey, backspace
                };
            }
        }).mount('#app');
    </script>
</body>

</html>