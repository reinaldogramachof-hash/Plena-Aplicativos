<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Plena Typer | Teste de Velocidade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #323437;
            color: #646669;
            font-family: 'Roboto Mono', monospace;
        }

        .active {
            color: #e2b714;
            border-left: 2px solid #e2b714;
            animation: blink 1s infinite;
        }

        .correct {
            color: #d1d0c5;
        }

        .error {
            color: #ca4754;
            text-decoration: underline;
        }

        .caret {
            border-right: 2px solid #e2b714;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% {
                border-color: transparent;
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center p-4">

    <div id="app" class="w-full max-w-4xl">

        <!-- Header -->
        <header class="flex justify-between items-end mb-12">
            <h1 class="text-3xl font-bold text-[#d1d0c5] flex items-center gap-3">
                <i class="fa-solid fa-keyboard text-[#e2b714]"></i> PlenaTyper
            </h1>
            <div class="flex gap-4 text-sm font-bold">
                <button v-for="t in [15, 30, 60]" :key="t" @click="setTime(t)"
                    :class="timeLimit === t ? 'text-[#e2b714]' : 'hover:text-[#d1d0c5] transition'">
                    {{ t }}s
                </button>
            </div>
        </header>

        <!-- Game Area -->
        <div v-if="!finished" class="relative">

            <!-- Timer -->
            <div class="absolute -top-10 left-0 text-2xl font-bold text-[#e2b714]">
                {{ timeLeft }}
            </div>

            <!-- Words Display -->
            <div class="text-2xl leading-relaxed select-none h-32 overflow-hidden relative"
                @click="$refs.input.focus()">
                <div :style="{ marginTop: -currentRow * 40 + 'px' }" class="transition-all duration-300">
                    <span v-for="(word, wIdx) in wordsList" :key="wIdx" class="mr-3 inline-block p-1 rounded"
                        :class="{ 'bg-white/5': currentWordIndex === wIdx }">
                        <span v-for="(char, cIdx) in word" :key="cIdx" :class="getCharClass(wIdx, cIdx)">{{ char
                            }}</span>
                    </span>
                </div>
            </div>

            <!-- Focus Overlay -->
            <div v-if="!focused" @click="$refs.input.focus()"
                class="absolute inset-0 flex items-center justify-center bg-[#323437]/90 cursor-pointer z-10 transition">
                <span class="text-xl text-[#d1d0c5]"><i class="fa-solid fa-arrow-pointer"></i> Clique aqui para
                    focar</span>
            </div>

            <!-- Hidden Input -->
            <input ref="input" type="text" v-model="userInput" @input="processInput" @focus="focused = true"
                @blur="focused = false" class="opacity-0 absolute top-0 left-0 w-full h-full cursor-default">

            <!-- Restart Hint -->
            <div class="mt-12 text-center opacity-50 text-sm">
                <span class="bg-[#2c2e31] px-2 py-1 rounded border border-[#646669]">Tab</span> para reiniciar
            </div>

        </div>

        <!-- Result Screen -->
        <div v-else class="text-center animate-fade-in-up">
            <div class="grid grid-cols-2 md:grid-cols-4 gap-8 mb-12">
                <div class="text-left">
                    <div class="text-4xl font-bold text-[#e2b714] mb-1">{{ wpm }}</div>
                    <div class="text-sm">WPM</div>
                </div>
                <div class="text-left">
                    <div class="text-4xl font-bold text-[#d1d0c5] mb-1">{{ accuracy }}%</div>
                    <div class="text-sm">Precis√£o</div>
                </div>
                <div class="text-left">
                    <div class="text-4xl font-bold text-[#d1d0c5] mb-1">{{ correctChars }}/<span
                            class="text-[#ca4754]">{{ errorChars }}</span></div>
                    <div class="text-sm">Chars (Certo/Errado)</div>
                </div>
                <div class="text-left">
                    <div class="text-4xl font-bold text-[#d1d0c5] mb-1">{{ timeLimit }}s</div>
                    <div class="text-sm">Tempo</div>
                </div>
            </div>

            <button @click="resetGame"
                class="bg-[#e2b714] hover:bg-[#d1a60a] text-[#323437] px-8 py-3 rounded text-xl font-bold transition">
                <i class="fa-solid fa-rotate-right mr-2"></i> Tentar Novamente
            </button>
        </div>

    </div>

    <script>
        const { createApp, ref, onMounted } = Vue;

        createApp({
            setup() {
                const wordsDB = ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit", "curabitur", "vel", "hendrerit", "libero", "eleifend", "blandit", "nunc", "ornare", "odio", "ut", "orci", "gravida", "imperdiet", "nullam", "purus", "lacinia", "a", "pretium", "quis", "congue", "praesent", "sagittis", "laoreet", "auctor", "mauris", "non", "velit", "eros", "dictum", "proin", "accumsan", "sapien", "nec", "massa", "volutpat", "venenatis", "sed", "eu", "molestie", "lacus", "quisque", "porttitor", "ligula", "dui", "mollis", "tempus", "at", "magna", "vestibulum", "turpis", "ac", "diam", "tincidunt", "id", "condimentum", "enim", "sodales", "in", "hac", "habitasse", "platea", "dictumst", "aenean", "neque", "fusce", "augue", "leo", "eget", "semper", "mattis", "tortor", "scelerisque", "nulla", "interdum", "tellus", "malesuada", "rhoncus", "porta", "sem", "aliquet", "et", "nam", "suspendisse", "potenti", "vivamus", "luctus", "fringilla", "erat", "donec", "justo", "vehicula", "ultricies", "varius", "ante", "primis", "faucibus", "ultrices", "posuere", "cubilia", "curae", "etiam", "cursus", "aliquam", "quam", "dapibus", "nisl", "feugiat", "egestas", "class", "aptent", "taciti", "sociosqu", "ad", "litora", "torquent", "per", "conubia", "nostra", "inceptos", "himenaeos", "phasellus", "nibh", "pulvinar", "vitae", "urna", "iaculis", "lobortis", "nisi", "viverra", "arcu", "morbi", "pellentesque", "metus", "commodo", "ut", "facilisis", "felis", "tristique", "ullamcorper", "placerat", "aenean", "convallis", "sollicitudin", "integer", "rutrum", "duis", "est", "etiam", "bibendum", "donec", "pharetra", "vulputate", "maecenas", "mi", "fermentum", "consequat", "suscipit", "aliquam", "habitant", "senectus", "netus", "fames", "quisque", "euismod", "curabitur", "lectus", "elementum", "tempor", "risus", "cras"];

                const timeLimit = ref(30);
                const timeLeft = ref(30);
                const isRunning = ref(false);
                const finished = ref(false);
                const focused = ref(false);
                const interval = ref(null);

                const wordsList = ref([]);
                const userInput = ref('');
                const currentWordIndex = ref(0);
                const currentRow = ref(0); // For scrolling

                // Stats
                const correctChars = ref(0);
                const errorChars = ref(0);
                const wpm = ref(0);
                const accuracy = ref(0);

                const setTime = (t) => {
                    timeLimit.value = t;
                    resetGame();
                };

                const resetGame = () => {
                    clearInterval(interval.value);
                    isRunning.value = false;
                    finished.value = false;
                    timeLeft.value = timeLimit.value;
                    userInput.value = '';
                    currentWordIndex.value = 0;
                    correctChars.value = 0;
                    errorChars.value = 0;
                    // Generate words (100 is enough buffer)
                    wordsList.value = Array.from({ length: 100 }, () => wordsDB[Math.floor(Math.random() * wordsDB.length)]);
                };

                const startGame = () => {
                    if (isRunning.value) return;
                    isRunning.value = true;
                    interval.value = setInterval(() => {
                        timeLeft.value--;
                        if (timeLeft.value <= 0) endGame();
                    }, 1000);
                };

                const endGame = () => {
                    clearInterval(interval.value);
                    finished.value = true;
                    isRunning.value = false;

                    // Calc WPM (Chars / 5) / (Time / 60)
                    const minutes = timeLimit.value / 60;
                    wpm.value = Math.round((correctChars.value / 5) / minutes);

                    const totalChars = correctChars.value + errorChars.value;
                    accuracy.value = totalChars > 0 ? Math.round((correctChars.value / totalChars) * 100) : 0;
                };

                const processInput = (e) => {
                    if (!isRunning.value && !finished.value) startGame();

                    const val = userInput.value;

                    // Handle Space (Next word)
                    if (val.endsWith(' ')) {
                        const word = wordsList.value[currentWordIndex.value];
                        const inputClippped = val.trim();

                        // Check logic (very simple stats update)
                        // In a real app we would lock the result of this word
                        // For now we just move on

                        // Check chars logic for stats:
                        for (let i = 0; i < inputClippped.length; i++) {
                            if (inputClippped[i] === word[i]) correctChars.value++;
                            else errorChars.value++;
                        }
                        // Plus the space
                        correctChars.value++;

                        currentWordIndex.value++;
                        userInput.value = '';

                        // Scroll logic (approx)
                        if (currentWordIndex.value > 0 && currentWordIndex.value % 10 === 0) {
                            // currentRow.value++;
                        }
                    }
                };

                const getCharClass = (wIdx, cIdx) => {
                    if (wIdx > currentWordIndex.value) return ''; // Future
                    const word = wordsList.value[wIdx];

                    if (wIdx === currentWordIndex.value) {
                        // Current typing
                        if (cIdx >= userInput.value.length) return ''; // Not typed yet
                        return userInput.value[cIdx] === word[cIdx] ? 'correct' : 'error';
                    } else {
                        // Past word (For simplicitly assuming correct in this view logic, 
                        // real logic would need state memory per word)
                        return 'text-white/50';
                    }
                };

                // Hotkey restart
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        resetGame();
                    }
                });

                onMounted(resetGame);

                return {
                    timeLimit, timeLeft, isRunning, finished, focused,
                    wordsList, userInput, currentWordIndex, currentRow,
                    wpm, accuracy, correctChars, errorChars,
                    setTime, resetGame, processInput, getCharClass
                };
            }
        }).mount('#app');
    </script>
</body>

</html>